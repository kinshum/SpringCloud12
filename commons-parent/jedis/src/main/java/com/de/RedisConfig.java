package com.de;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Lazy;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.GenericToStringSerializer;import redis.clients.jedis.HostAndPort;import redis.clients.jedis.JedisCluster;import redis.clients.jedis.JedisPoolConfig;import java.util.HashSet;import java.util.Set;/**   * * @author jensen  * @description          * @date 2018/5/1 3:50 * @param * @return  */@Configuration@ConditionalOnClass({JedisCluster.class})public class RedisConfig {    @Value("${spring.redis.cluster.nodes}")    private String clusterNodes;    @Value("${spring.redis.timeout}")    private int timeout;    @Value("${spring.redis.pool.max-idle}")    private int maxIdle;    @Value("${spring.redis.pool.max-wait}")    private long maxWaitMillis;    @Value("${spring.redis.commandTimeout}")    private int commandTimeout;    @Bean    public JedisCluster getJedisCluster() {        String[] cNodes = clusterNodes.split(",");        Set<HostAndPort> nodes = new HashSet<>();        // 分割出集群节点        for (String node : cNodes) {            String[] hp = node.split(":");            nodes.add(new HostAndPort(hp[0],Integer.parseInt(hp[1])));        }        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();        jedisPoolConfig.setMaxIdle(maxIdle);        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);        // 创建集群对象//      JedisCluster jedisCluster = new JedisCluster(nodes,commandTimeout);        return new JedisCluster(nodes,commandTimeout,jedisPoolConfig);    }   /**    *    * @author jensen    * @description * 设置数据存入 redis 的序列化方式    * </br>redisTemplate 序列化默认使用的jdkSerializeable, 存储二进制字节码, 导致key会出现乱码，所以自定义    * 序列化类    * @date 2018/5/1 3:50    * @param [connectionFactory]    * @return org.springframework.data.redis.core.RedisTemplate    */    @SuppressWarnings({ "unchecked", "rawtypes" })    @Bean("redisTemplate")    public RedisTemplate redisTemplate(@Lazy RedisConnectionFactory connectionFactory) {        RedisTemplate redis = new RedisTemplate();        GenericToStringSerializer<String> keySerializer = new GenericToStringSerializer<String>(String.class);        redis.setKeySerializer(keySerializer);        redis.setHashKeySerializer(keySerializer);        GenericJackson2JsonRedisSerializer valueSerializer = new GenericJackson2JsonRedisSerializer();        redis.setValueSerializer(valueSerializer);        redis.setHashValueSerializer(valueSerializer);        redis.setConnectionFactory(connectionFactory);        return redis;    }}